import { SvelteComponent, init, safe_not_equal, element, text, attr, insert, append, set_data, detach, space, noop, destroy_each, component_subscribe, create_slot, listen, update_slot, transition_in, transition_out, run_all, set_store_value, binding_callbacks, action_destroyer, is_function, create_component, mount_component, destroy_component, group_outros, check_outros, empty } from 'svelte/internal';
import { getContext, tick, onMount, afterUpdate, setContext } from 'svelte';
import { derived, writable } from 'svelte/store';
import { cloneDate, subtractDay, addDay, hasYScroll, sortEventChunks, setMidnight, datesEqual, setContent, toEventWithLocalDates, toViewWithLocalDates, createEventContent, createDate, toLocalDate, createEventChunk } from '@event-calendar/common';

function days(state) {
    return derived([state.date, state.firstDay, state.hiddenDays], ([$date, $firstDay, $hiddenDays]) => {
        let days = [];
        let day = cloneDate($date);
        let max = 7;
        // First day of week
        while (day.getUTCDay() !== $firstDay && max) {
            subtractDay(day);
            --max;
        }
        for (let i = 0; i < 7; ++i) {
            if (!$hiddenDays.includes(day.getUTCDay())) {
                days.push(cloneDate(day));
            }
            addDay(day);
        }

        return days;
    });
}

class State {
    constructor(state) {
        this._days = days(state);
    }
}

/* packages/day-grid/src/Header.svelte generated by Svelte v3.38.2 */

function get_each_context$3(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[8] = list[i];
	return child_ctx;
}

// (10:2) {#each $_days as day}
function create_each_block$3(ctx) {
	let div;
	let t_value = /*$_intlDayHeader*/ ctx[3].format(/*day*/ ctx[8]) + "";
	let t;
	let div_class_value;

	return {
		c() {
			div = element("div");
			t = text(t_value);
			attr(div, "class", div_class_value = /*$theme*/ ctx[0].day);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, t);
		},
		p(ctx, dirty) {
			if (dirty & /*$_intlDayHeader, $_days*/ 12 && t_value !== (t_value = /*$_intlDayHeader*/ ctx[3].format(/*day*/ ctx[8]) + "")) set_data(t, t_value);

			if (dirty & /*$theme*/ 1 && div_class_value !== (div_class_value = /*$theme*/ ctx[0].day)) {
				attr(div, "class", div_class_value);
			}
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

function create_fragment$5(ctx) {
	let div2;
	let div0;
	let div0_class_value;
	let t;
	let div1;
	let div1_class_value;
	let div2_class_value;
	let each_value = /*$_days*/ ctx[2];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
	}

	return {
		c() {
			div2 = element("div");
			div0 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t = space();
			div1 = element("div");
			attr(div0, "class", div0_class_value = /*$theme*/ ctx[0].days);
			attr(div1, "class", div1_class_value = /*$theme*/ ctx[0].hiddenScroll);

			attr(div2, "class", div2_class_value = "" + (/*$theme*/ ctx[0].header + " " + /*$theme*/ ctx[0].month + (/*$_scrollable*/ ctx[1]
			? " " + /*$theme*/ ctx[0].withScroll
			: "")));
		},
		m(target, anchor) {
			insert(target, div2, anchor);
			append(div2, div0);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div0, null);
			}

			append(div2, t);
			append(div2, div1);
		},
		p(ctx, [dirty]) {
			if (dirty & /*$theme, $_intlDayHeader, $_days*/ 13) {
				each_value = /*$_days*/ ctx[2];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$3(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$3(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div0, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (dirty & /*$theme*/ 1 && div0_class_value !== (div0_class_value = /*$theme*/ ctx[0].days)) {
				attr(div0, "class", div0_class_value);
			}

			if (dirty & /*$theme*/ 1 && div1_class_value !== (div1_class_value = /*$theme*/ ctx[0].hiddenScroll)) {
				attr(div1, "class", div1_class_value);
			}

			if (dirty & /*$theme, $_scrollable*/ 3 && div2_class_value !== (div2_class_value = "" + (/*$theme*/ ctx[0].header + " " + /*$theme*/ ctx[0].month + (/*$_scrollable*/ ctx[1]
			? " " + /*$theme*/ ctx[0].withScroll
			: "")))) {
				attr(div2, "class", div2_class_value);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div2);
			destroy_each(each_blocks, detaching);
		}
	};
}

function instance$5($$self, $$props, $$invalidate) {
	let $theme;
	let $_scrollable;
	let $_days;
	let $_intlDayHeader;
	let { theme, _intlDayHeader, _scrollable } = getContext("state");
	component_subscribe($$self, theme, value => $$invalidate(0, $theme = value));
	component_subscribe($$self, _intlDayHeader, value => $$invalidate(3, $_intlDayHeader = value));
	component_subscribe($$self, _scrollable, value => $$invalidate(1, $_scrollable = value));
	let { _days } = getContext("view-state");
	component_subscribe($$self, _days, value => $$invalidate(2, $_days = value));

	return [
		$theme,
		$_scrollable,
		$_days,
		$_intlDayHeader,
		theme,
		_intlDayHeader,
		_scrollable,
		_days
	];
}

class Header extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$5, create_fragment$5, safe_not_equal, {});
	}
}

/* packages/day-grid/src/Body.svelte generated by Svelte v3.38.2 */

function create_fragment$4(ctx) {
	let div1;
	let div0;
	let div0_class_value;
	let div1_class_value;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[10].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], null);

	return {
		c() {
			div1 = element("div");
			div0 = element("div");
			if (default_slot) default_slot.c();
			attr(div0, "class", div0_class_value = /*$theme*/ ctx[1].content);
			attr(div1, "class", div1_class_value = "" + (/*$theme*/ ctx[1].body + " " + /*$theme*/ ctx[1].month));
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, div0);

			if (default_slot) {
				default_slot.m(div0, null);
			}

			/*div1_binding*/ ctx[11](div1);
			current = true;

			if (!mounted) {
				dispose = [
					listen(window, "resize", /*recheckScrollable*/ ctx[6]),
					listen(div1, "scroll", /*handleScroll*/ ctx[7])
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 512)) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[9], dirty, null, null);
				}
			}

			if (!current || dirty & /*$theme*/ 2 && div0_class_value !== (div0_class_value = /*$theme*/ ctx[1].content)) {
				attr(div0, "class", div0_class_value);
			}

			if (!current || dirty & /*$theme*/ 2 && div1_class_value !== (div1_class_value = "" + (/*$theme*/ ctx[1].body + " " + /*$theme*/ ctx[1].month))) {
				attr(div1, "class", div1_class_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			if (default_slot) default_slot.d(detaching);
			/*div1_binding*/ ctx[11](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance$4($$self, $$props, $$invalidate) {
	let $_events;
	let $_scrollable;
	let $_interaction;
	let $theme;
	let { $$slots: slots = {}, $$scope } = $$props;
	let { _events, _scrollable, _interaction, theme } = getContext("state");
	component_subscribe($$self, _events, value => $$invalidate(8, $_events = value));
	component_subscribe($$self, _scrollable, value => $$invalidate(12, $_scrollable = value));
	component_subscribe($$self, _interaction, value => $$invalidate(13, $_interaction = value));
	component_subscribe($$self, theme, value => $$invalidate(1, $theme = value));
	let el;

	function recheckScrollable() {
		set_store_value(_scrollable, $_scrollable = hasYScroll(el), $_scrollable);
	}

	function handleScroll() {
		if ($_interaction.drag) {
			$_interaction.drag.handleScroll();
		}
	}

	function div1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			el = $$value;
			$$invalidate(0, el);
		});
	}

	$$self.$$set = $$props => {
		if ("$$scope" in $$props) $$invalidate(9, $$scope = $$props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*el, $_events*/ 257) {
			if (el && $_events) {
				tick().then(recheckScrollable);
			}
		}
	};

	return [
		el,
		$theme,
		_events,
		_scrollable,
		_interaction,
		theme,
		recheckScrollable,
		handleScroll,
		$_events,
		$$scope,
		slots,
		div1_binding
	];
}

class Body extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$4, create_fragment$4, safe_not_equal, {});
	}
}

function prepareEventChunks(chunks, hiddenDays) {
    if (!chunks.length) {
        return;
    }

    sortEventChunks(chunks);

    let longChunks = {};
    let prevChunk;
    for (let chunk of chunks) {
        while (hiddenDays.includes(chunk.start.getUTCDay())) {
            // Try to move the start up to the first visible day
            let start = addDay(setMidnight(cloneDate(chunk.start)));
            if (start > chunk.end) {
                break;
            }
            chunk.start = start;
        }
        chunk.date = setMidnight(cloneDate(chunk.start));
        chunk.days = 1;
        let date = addDay(cloneDate(chunk.date));
        while (chunk.end > date) {
            ++chunk.days;
            let key = date.getTime();
            if (longChunks[key]) {
                longChunks[key].push(chunk);
            } else {
                longChunks[key] = [chunk];
            }
            addDay(date);
        }
        if (prevChunk && datesEqual(prevChunk.date, chunk.date)) {
            chunk.prev = prevChunk;
        }
        prevChunk = chunk;
    }

    return longChunks;
}

/* packages/day-grid/src/Event.svelte generated by Svelte v3.38.2 */

function create_fragment$3(ctx) {
	let div;
	let setContent_action;
	let mounted;
	let dispose;

	return {
		c() {
			div = element("div");
			attr(div, "class", /*classes*/ ctx[3]);
			attr(div, "style", /*style*/ ctx[4]);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			/*div_binding*/ ctx[35](div);

			if (!mounted) {
				dispose = [
					listen(window, "resize", /*reposition*/ ctx[24]),
					action_destroyer(setContent_action = setContent.call(null, div, /*content*/ ctx[5])),
					listen(div, "click", function () {
						if (is_function(/*createHandler*/ ctx[22](/*$eventClick*/ ctx[6], /*display*/ ctx[0]))) /*createHandler*/ ctx[22](/*$eventClick*/ ctx[6], /*display*/ ctx[0]).apply(this, arguments);
					}),
					listen(div, "mouseenter", function () {
						if (is_function(/*createHandler*/ ctx[22](/*$eventMouseEnter*/ ctx[7], /*display*/ ctx[0]))) /*createHandler*/ ctx[22](/*$eventMouseEnter*/ ctx[7], /*display*/ ctx[0]).apply(this, arguments);
					}),
					listen(div, "mouseleave", function () {
						if (is_function(/*createHandler*/ ctx[22](/*$eventMouseLeave*/ ctx[8], /*display*/ ctx[0]))) /*createHandler*/ ctx[22](/*$eventMouseLeave*/ ctx[8], /*display*/ ctx[0]).apply(this, arguments);
					}),
					listen(div, "mousedown", function () {
						if (is_function(/*createDragStartHandler*/ ctx[23](/*$_interaction*/ ctx[1], /*display*/ ctx[0]))) /*createDragStartHandler*/ ctx[23](/*$_interaction*/ ctx[1], /*display*/ ctx[0]).apply(this, arguments);
					}),
					listen(div, "touchstart", function () {
						if (is_function(/*createDragStartHandler*/ ctx[23](/*$_interaction*/ ctx[1], /*display*/ ctx[0]))) /*createDragStartHandler*/ ctx[23](/*$_interaction*/ ctx[1], /*display*/ ctx[0]).apply(this, arguments);
					})
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty[0] & /*classes*/ 8) {
				attr(div, "class", /*classes*/ ctx[3]);
			}

			if (dirty[0] & /*style*/ 16) {
				attr(div, "style", /*style*/ ctx[4]);
			}

			if (setContent_action && is_function(setContent_action.update) && dirty[0] & /*content*/ 32) setContent_action.update.call(null, /*content*/ ctx[5]);
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div);
			/*div_binding*/ ctx[35](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance$3($$self, $$props, $$invalidate) {
	let $eventBackgroundColor;
	let $eventColor;
	let $margin;
	let $_interaction;
	let $theme;
	let $displayEventEnd;
	let $eventContent;
	let $_intlEventTime;
	let $_view;
	let $eventDidMount;
	let $eventClick;
	let $eventMouseEnter;
	let $eventMouseLeave;
	let { chunk } = $$props;
	let { longChunks = {} } = $$props;
	let { displayEventEnd, eventBackgroundColor, eventClick, eventColor, eventContent, eventDidMount, eventMouseEnter, eventMouseLeave, theme, _view, _intlEventTime, _interaction } = getContext("state");
	component_subscribe($$self, displayEventEnd, value => $$invalidate(31, $displayEventEnd = value));
	component_subscribe($$self, eventBackgroundColor, value => $$invalidate(27, $eventBackgroundColor = value));
	component_subscribe($$self, eventClick, value => $$invalidate(6, $eventClick = value));
	component_subscribe($$self, eventColor, value => $$invalidate(28, $eventColor = value));
	component_subscribe($$self, eventContent, value => $$invalidate(32, $eventContent = value));
	component_subscribe($$self, eventDidMount, value => $$invalidate(37, $eventDidMount = value));
	component_subscribe($$self, eventMouseEnter, value => $$invalidate(7, $eventMouseEnter = value));
	component_subscribe($$self, eventMouseLeave, value => $$invalidate(8, $eventMouseLeave = value));
	component_subscribe($$self, theme, value => $$invalidate(30, $theme = value));
	component_subscribe($$self, _view, value => $$invalidate(34, $_view = value));
	component_subscribe($$self, _intlEventTime, value => $$invalidate(33, $_intlEventTime = value));
	component_subscribe($$self, _interaction, value => $$invalidate(1, $_interaction = value));
	let el;
	let classes;
	let style;
	let content;
	let timeText;
	let margin = writable(1);
	component_subscribe($$self, margin, value => $$invalidate(29, $margin = value));
	let display;

	onMount(() => {
		if (is_function($eventDidMount)) {
			$eventDidMount({
				event: toEventWithLocalDates(chunk.event),
				timeText,
				el,
				view: toViewWithLocalDates($_view)
			});
		}
	});

	afterUpdate(reposition);

	function createHandler(fn, display) {
		return display !== "preview" && is_function(fn)
		? jsEvent => fn({
				event: toEventWithLocalDates(chunk.event),
				el,
				jsEvent,
				view: toViewWithLocalDates($_view)
			})
		: undefined;
	}

	function createDragStartHandler(interaction, display) {
		return display === "auto" && interaction.drag
		? jsEvent => interaction.drag.startDayGrid(chunk.event, el, jsEvent)
		: undefined;
	}

	function reposition() {
		if (!el || display === "preview") {
			return;
		}

		let c = chunk;
		c.top = 0;

		if (c.prev) {
			if (c.prev.bottom === undefined) {
				// 'prev' is not ready yet, try again later
				tick().then(reposition);

				return;
			}

			c.top = c.prev.bottom + 1;
		}

		c.bottom = c.top + el.offsetHeight;
		let m = 1;
		let key = c.date.getTime();

		if (longChunks[key]) {
			for (let longChunk of longChunks[key]) {
				if (longChunk.bottom === undefined) {
					// 'longChunk' is not ready yet, try again later
					tick().then(reposition);

					return;
				}

				if (c.top < longChunk.bottom && c.bottom > longChunk.top) {
					let offset = longChunk.bottom - c.top + 1;
					m += offset;
					c.top += offset;
					c.bottom += offset;
				}
			}
		}

		set_store_value(margin, $margin = m, $margin);
	}

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			el = $$value;
			$$invalidate(2, el);
		});
	}

	$$self.$$set = $$props => {
		if ("chunk" in $$props) $$invalidate(25, chunk = $$props.chunk);
		if ("longChunks" in $$props) $$invalidate(26, longChunks = $$props.longChunks);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*chunk, $eventBackgroundColor, $eventColor, $margin, style, $_interaction, display, $theme*/ 2046820371) {
			{
				$$invalidate(0, display = chunk.event.display);

				// Class & Style
				let bgColor = chunk.event.backgroundColor || $eventBackgroundColor || $eventColor;

				$$invalidate(4, style = `width:calc(${chunk.days * 100}% + ${(chunk.days - 1) * 7}px);` + `margin-top:${$margin}px;`);

				if (bgColor) {
					$$invalidate(4, style += `background-color:${bgColor};`);
				}

				$$invalidate(3, classes = $_interaction.drag
				? $_interaction.drag.classes(display, $theme.event)
				: $theme.event);
			}
		}

		if ($$self.$$.dirty[0] & /*chunk, $theme*/ 1107296256 | $$self.$$.dirty[1] & /*$displayEventEnd, $eventContent, $_intlEventTime, $_view*/ 15) {
			// Content
			$$invalidate(5, [timeText, content] = createEventContent(chunk, $displayEventEnd, $eventContent, $theme, $_intlEventTime, $_view), content);
		}
	};

	return [
		display,
		$_interaction,
		el,
		classes,
		style,
		content,
		$eventClick,
		$eventMouseEnter,
		$eventMouseLeave,
		displayEventEnd,
		eventBackgroundColor,
		eventClick,
		eventColor,
		eventContent,
		eventDidMount,
		eventMouseEnter,
		eventMouseLeave,
		theme,
		_view,
		_intlEventTime,
		_interaction,
		margin,
		createHandler,
		createDragStartHandler,
		reposition,
		chunk,
		longChunks,
		$eventBackgroundColor,
		$eventColor,
		$margin,
		$theme,
		$displayEventEnd,
		$eventContent,
		$_intlEventTime,
		$_view,
		div_binding
	];
}

class Event extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$3, create_fragment$3, safe_not_equal, { chunk: 25, longChunks: 26 }, [-1, -1]);
	}
}

/* packages/day-grid/src/Day.svelte generated by Svelte v3.38.2 */

function get_each_context$2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[20] = list[i];
	return child_ctx;
}

// (50:1) {#if dragChunk && datesEqual(dragChunk.date, date)}
function create_if_block(ctx) {
	let div;
	let event;
	let div_class_value;
	let current;
	event = new Event({ props: { chunk: /*dragChunk*/ ctx[2] } });

	return {
		c() {
			div = element("div");
			create_component(event.$$.fragment);
			attr(div, "class", div_class_value = "" + (/*$theme*/ ctx[7].events + " " + /*$theme*/ ctx[7].preview));
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(event, div, null);
			current = true;
		},
		p(ctx, dirty) {
			const event_changes = {};
			if (dirty & /*dragChunk*/ 4) event_changes.chunk = /*dragChunk*/ ctx[2];
			event.$set(event_changes);

			if (!current || dirty & /*$theme*/ 128 && div_class_value !== (div_class_value = "" + (/*$theme*/ ctx[7].events + " " + /*$theme*/ ctx[7].preview))) {
				attr(div, "class", div_class_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(event.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(event.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(event);
		}
	};
}

// (56:2) {#each dayChunks as chunk}
function create_each_block$2(ctx) {
	let event;
	let current;

	event = new Event({
			props: {
				chunk: /*chunk*/ ctx[20],
				longChunks: /*longChunks*/ ctx[1]
			}
		});

	return {
		c() {
			create_component(event.$$.fragment);
		},
		m(target, anchor) {
			mount_component(event, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const event_changes = {};
			if (dirty & /*dayChunks*/ 8) event_changes.chunk = /*chunk*/ ctx[20];
			if (dirty & /*longChunks*/ 2) event_changes.longChunks = /*longChunks*/ ctx[1];
			event.$set(event_changes);
		},
		i(local) {
			if (current) return;
			transition_in(event.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(event.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(event, detaching);
		}
	};
}

function create_fragment$2(ctx) {
	let div2;
	let div0;
	let t0_value = /*date*/ ctx[0].getUTCDate() + "";
	let t0;
	let div0_class_value;
	let t1;
	let show_if = /*dragChunk*/ ctx[2] && datesEqual(/*dragChunk*/ ctx[2].date, /*date*/ ctx[0]);
	let t2;
	let div1;
	let div1_class_value;
	let div2_class_value;
	let current;
	let mounted;
	let dispose;
	let if_block = show_if && create_if_block(ctx);
	let each_value = /*dayChunks*/ ctx[3];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	return {
		c() {
			div2 = element("div");
			div0 = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (if_block) if_block.c();
			t2 = space();
			div1 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(div0, "class", div0_class_value = /*$theme*/ ctx[7].dayHead);
			attr(div1, "class", div1_class_value = /*$theme*/ ctx[7].events);

			attr(div2, "class", div2_class_value = "" + (/*$theme*/ ctx[7].day + (/*isToday*/ ctx[4] ? " " + /*$theme*/ ctx[7].today : "") + (/*otherMonth*/ ctx[5]
			? " " + /*$theme*/ ctx[7].otherMonth
			: "") + (/*highlight*/ ctx[6]
			? " " + /*$theme*/ ctx[7].highlight
			: "")));
		},
		m(target, anchor) {
			insert(target, div2, anchor);
			append(div2, div0);
			append(div0, t0);
			append(div2, t1);
			if (if_block) if_block.m(div2, null);
			append(div2, t2);
			append(div2, div1);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div1, null);
			}

			current = true;

			if (!mounted) {
				dispose = listen(div2, "click", function () {
					if (is_function(/*createClickHandler*/ ctx[14](/*$dateClick*/ ctx[8]))) /*createClickHandler*/ ctx[14](/*$dateClick*/ ctx[8]).apply(this, arguments);
				});

				mounted = true;
			}
		},
		p(new_ctx, [dirty]) {
			ctx = new_ctx;
			if ((!current || dirty & /*date*/ 1) && t0_value !== (t0_value = /*date*/ ctx[0].getUTCDate() + "")) set_data(t0, t0_value);

			if (!current || dirty & /*$theme*/ 128 && div0_class_value !== (div0_class_value = /*$theme*/ ctx[7].dayHead)) {
				attr(div0, "class", div0_class_value);
			}

			if (dirty & /*dragChunk, date*/ 5) show_if = /*dragChunk*/ ctx[2] && datesEqual(/*dragChunk*/ ctx[2].date, /*date*/ ctx[0]);

			if (show_if) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*dragChunk, date*/ 5) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div2, t2);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (dirty & /*dayChunks, longChunks*/ 10) {
				each_value = /*dayChunks*/ ctx[3];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$2(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$2(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(div1, null);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}

			if (!current || dirty & /*$theme*/ 128 && div1_class_value !== (div1_class_value = /*$theme*/ ctx[7].events)) {
				attr(div1, "class", div1_class_value);
			}

			if (!current || dirty & /*$theme, isToday, otherMonth, highlight*/ 240 && div2_class_value !== (div2_class_value = "" + (/*$theme*/ ctx[7].day + (/*isToday*/ ctx[4] ? " " + /*$theme*/ ctx[7].today : "") + (/*otherMonth*/ ctx[5]
			? " " + /*$theme*/ ctx[7].otherMonth
			: "") + (/*highlight*/ ctx[6]
			? " " + /*$theme*/ ctx[7].highlight
			: "")))) {
				attr(div2, "class", div2_class_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			transition_out(if_block);
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) detach(div2);
			if (if_block) if_block.d();
			destroy_each(each_blocks, detaching);
			mounted = false;
			dispose();
		}
	};
}

function instance$2($$self, $$props, $$invalidate) {
	let $currentDate;
	let $highlightedDates;
	let $_view;
	let $theme;
	let $dateClick;
	let { date } = $$props;
	let { chunks } = $$props;
	let { longChunks } = $$props;
	let { dragChunk = null } = $$props;
	let { date: currentDate, dateClick, highlightedDates, _view, theme } = getContext("state");
	component_subscribe($$self, currentDate, value => $$invalidate(16, $currentDate = value));
	component_subscribe($$self, dateClick, value => $$invalidate(8, $dateClick = value));
	component_subscribe($$self, highlightedDates, value => $$invalidate(17, $highlightedDates = value));
	component_subscribe($$self, _view, value => $$invalidate(18, $_view = value));
	component_subscribe($$self, theme, value => $$invalidate(7, $theme = value));
	let dayChunks;
	let today = setMidnight(createDate()), isToday, otherMonth, highlight;

	function createClickHandler(fn) {
		return is_function(fn)
		? jsEvent => fn({
				date: toLocalDate(date),
				jsEvent,
				view: toViewWithLocalDates($_view)
			})
		: undefined;
	}

	$$self.$$set = $$props => {
		if ("date" in $$props) $$invalidate(0, date = $$props.date);
		if ("chunks" in $$props) $$invalidate(15, chunks = $$props.chunks);
		if ("longChunks" in $$props) $$invalidate(1, longChunks = $$props.longChunks);
		if ("dragChunk" in $$props) $$invalidate(2, dragChunk = $$props.dragChunk);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*chunks, date, dayChunks*/ 32777) {
			{
				$$invalidate(3, dayChunks = []);

				for (let chunk of chunks) {
					if (datesEqual(chunk.date, date)) {
						dayChunks.push(chunk);
					}
				}
			}
		}

		if ($$self.$$.dirty & /*date, $currentDate, $highlightedDates*/ 196609) {
			{
				$$invalidate(4, isToday = datesEqual(date, today));
				$$invalidate(5, otherMonth = date.getUTCMonth() !== $currentDate.getUTCMonth());
				$$invalidate(6, highlight = $highlightedDates.some(d => datesEqual(d, date)));
			}
		}
	};

	return [
		date,
		longChunks,
		dragChunk,
		dayChunks,
		isToday,
		otherMonth,
		highlight,
		$theme,
		$dateClick,
		currentDate,
		dateClick,
		highlightedDates,
		_view,
		theme,
		createClickHandler,
		chunks,
		$currentDate,
		$highlightedDates
	];
}

class Day extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$2, create_fragment$2, safe_not_equal, {
			date: 0,
			chunks: 15,
			longChunks: 1,
			dragChunk: 2
		});
	}
}

/* packages/day-grid/src/Week.svelte generated by Svelte v3.38.2 */

function get_each_context$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[15] = list[i];
	return child_ctx;
}

// (49:1) {#each dates as date}
function create_each_block$1(ctx) {
	let day;
	let current;

	day = new Day({
			props: {
				date: /*date*/ ctx[15],
				chunks: /*chunks*/ ctx[1],
				longChunks: /*longChunks*/ ctx[3],
				dragChunk: /*dragChunk*/ ctx[2]
			}
		});

	return {
		c() {
			create_component(day.$$.fragment);
		},
		m(target, anchor) {
			mount_component(day, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const day_changes = {};
			if (dirty & /*dates*/ 1) day_changes.date = /*date*/ ctx[15];
			if (dirty & /*chunks*/ 2) day_changes.chunks = /*chunks*/ ctx[1];
			if (dirty & /*longChunks*/ 8) day_changes.longChunks = /*longChunks*/ ctx[3];
			if (dirty & /*dragChunk*/ 4) day_changes.dragChunk = /*dragChunk*/ ctx[2];
			day.$set(day_changes);
		},
		i(local) {
			if (current) return;
			transition_in(day.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(day.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(day, detaching);
		}
	};
}

function create_fragment$1(ctx) {
	let div;
	let div_class_value;
	let current;
	let each_value = /*dates*/ ctx[0];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	return {
		c() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(div, "class", div_class_value = /*$theme*/ ctx[4].days);
		},
		m(target, anchor) {
			insert(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (dirty & /*dates, chunks, longChunks, dragChunk*/ 15) {
				each_value = /*dates*/ ctx[0];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$1(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$1(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(div, null);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}

			if (!current || dirty & /*$theme*/ 16 && div_class_value !== (div_class_value = /*$theme*/ ctx[4].days)) {
				attr(div, "class", div_class_value);
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_each(each_blocks, detaching);
		}
	};
}

function instance$1($$self, $$props, $$invalidate) {
	let $_events;
	let $hiddenDays;
	let $_dragEvent;
	let $theme;
	let { dates } = $$props;
	let { _events, _dragEvent, hiddenDays, theme } = getContext("state");
	component_subscribe($$self, _events, value => $$invalidate(11, $_events = value));
	component_subscribe($$self, _dragEvent, value => $$invalidate(13, $_dragEvent = value));
	component_subscribe($$self, hiddenDays, value => $$invalidate(12, $hiddenDays = value));
	component_subscribe($$self, theme, value => $$invalidate(4, $theme = value));
	let chunks;
	let longChunks;
	let dragChunk;
	let start;
	let end;

	function intersects(event) {
		return event.start < end && event.end > start;
	}

	$$self.$$set = $$props => {
		if ("dates" in $$props) $$invalidate(0, dates = $$props.dates);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*dates*/ 1) {
			{
				$$invalidate(9, start = dates[0]);
				$$invalidate(10, end = addDay(cloneDate(dates[dates.length - 1])));
			}
		}

		if ($$self.$$.dirty & /*$_events, start, end, chunks, $hiddenDays*/ 7682) {
			{
				$$invalidate(1, chunks = []);

				for (let event of $_events) {
					if (event.display !== "background" && intersects(event)) {
						let chunk = createEventChunk(event, start, end);
						chunks.push(chunk);
					}
				}

				$$invalidate(3, longChunks = prepareEventChunks(chunks, $hiddenDays));
			}
		}

		if ($$self.$$.dirty & /*$_dragEvent, start, end, dragChunk, $hiddenDays*/ 13828) {
			// Drag & drop
			if ($_dragEvent && intersects($_dragEvent)) {
				$$invalidate(2, dragChunk = createEventChunk($_dragEvent, start, end));
				prepareEventChunks([dragChunk], $hiddenDays);
			} else {
				$$invalidate(2, dragChunk = null);
			}
		}
	};

	return [
		dates,
		chunks,
		dragChunk,
		longChunks,
		$theme,
		_events,
		_dragEvent,
		hiddenDays,
		theme,
		start,
		end,
		$_events,
		$hiddenDays,
		$_dragEvent
	];
}

class Week extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$1, create_fragment$1, safe_not_equal, { dates: 0 });
	}
}

/* packages/day-grid/src/View.svelte generated by Svelte v3.38.2 */

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[8] = list[i];
	return child_ctx;
}

// (31:1) {#each weeks as dates}
function create_each_block(ctx) {
	let week;
	let current;
	week = new Week({ props: { dates: /*dates*/ ctx[8] } });

	return {
		c() {
			create_component(week.$$.fragment);
		},
		m(target, anchor) {
			mount_component(week, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const week_changes = {};
			if (dirty & /*weeks*/ 1) week_changes.dates = /*dates*/ ctx[8];
			week.$set(week_changes);
		},
		i(local) {
			if (current) return;
			transition_in(week.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(week.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(week, detaching);
		}
	};
}

// (30:0) <Body>
function create_default_slot(ctx) {
	let each_1_anchor;
	let current;
	let each_value = /*weeks*/ ctx[0];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert(target, each_1_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (dirty & /*weeks*/ 1) {
				each_value = /*weeks*/ ctx[0];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach(each_1_anchor);
		}
	};
}

function create_fragment(ctx) {
	let header;
	let t;
	let body;
	let current;
	header = new Header({});

	body = new Body({
			props: {
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(header.$$.fragment);
			t = space();
			create_component(body.$$.fragment);
		},
		m(target, anchor) {
			mount_component(header, target, anchor);
			insert(target, t, anchor);
			mount_component(body, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const body_changes = {};

			if (dirty & /*$$scope, weeks*/ 2049) {
				body_changes.$$scope = { dirty, ctx };
			}

			body.$set(body_changes);
		},
		i(local) {
			if (current) return;
			transition_in(header.$$.fragment, local);
			transition_in(body.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(header.$$.fragment, local);
			transition_out(body.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(header, detaching);
			if (detaching) detach(t);
			destroy_component(body, detaching);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let $hiddenDays;
	let $_viewDates;
	let { _viewDates, hiddenDays, theme } = getContext("state");
	component_subscribe($$self, _viewDates, value => $$invalidate(5, $_viewDates = value));
	component_subscribe($$self, hiddenDays, value => $$invalidate(4, $hiddenDays = value));
	let state = new State(getContext("state"));
	setContext("view-state", state);
	let weeks;
	let days;

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*$hiddenDays, $_viewDates, days, weeks*/ 57) {
			{
				$$invalidate(0, weeks = []);
				$$invalidate(3, days = 7 - $hiddenDays.length);

				for (let i = 0; i < $_viewDates.length / days; ++i) {
					let dates = [];

					for (let j = 0; j < days; ++j) {
						dates.push($_viewDates[i * days + j]);
					}

					weeks.push(dates);
				}
			}
		}
	};

	return [weeks, _viewDates, hiddenDays, days, $hiddenDays, $_viewDates];
}

class View extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, {});
	}
}

var index = {
	createOptions(options) {
		// Common options
		options.buttonText.dayGridMonth = 'month';
		options.theme.month = 'ec-month';
		options.view = 'dayGridMonth';
		options.views.dayGridMonth = {
			component: View,
			dayHeaderFormat: {weekday: 'short'},
			displayEventEnd: false,
			duration: {months: 1},
			monthMode: true,
			titleFormat: {year: 'numeric', month: 'long'}
		};
	}
};

export default index;
