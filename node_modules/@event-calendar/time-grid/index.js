import { SvelteComponent, init, safe_not_equal, element, text, attr, insert, append, set_data, detach, create_slot, space, update_slot, transition_in, transition_out, destroy_each, component_subscribe, listen, run_all, set_store_value, binding_callbacks, action_destroyer, is_function, noop, create_component, mount_component, destroy_component, group_outros, check_outros, empty } from 'svelte/internal';
import { getContext, tick, onMount, setContext } from 'svelte';
import { derived } from 'svelte/store';
import { createDuration, DAY_IN_SECONDS, addDuration, cloneDate, createDate, hasYScroll, sortEventChunks, setContent, toEventWithLocalDates, toViewWithLocalDates, createEventContent, setMidnight, createEventChunk, datesEqual, rect, toLocalDate } from '@event-calendar/common';

function times(state, localState) {
    return derived(
        [localState._slotTimeLimits, state._intlSlotLabel, state.slotDuration],
        ([$_slotTimeLimits, $_intlSlotLabel, $slotDuration]) => {
            let compact = $slotDuration.seconds >= 3600;
            let times = [];
            let date = createDate('2020-01-01');
            let end = cloneDate(date);
            let i = 1;
            addDuration(date, $_slotTimeLimits.min);
            addDuration(end, $_slotTimeLimits.max);
            while (date < end) {
                times.push(times.length && (i || compact) ? $_intlSlotLabel.format(date) : '');
                addDuration(date, $slotDuration);
                i = 1 - i;
            }

            return times;
        }
    );
}

function slotTimeLimits(state) {
    return derived(
        [state._events, state._viewDates, state.flexibleSlotTimeLimits, state.slotMinTime, state.slotMaxTime],
        ([$_events, $_viewDates, $flexibleSlotTimeLimits, $slotMinTime, $slotMaxTime]) => {
            let min = createDuration($slotMinTime);
            let max = createDuration($slotMaxTime);

            if ($flexibleSlotTimeLimits) {
                let minMin = createDuration(Math.min(min.seconds, Math.max(0, max.seconds - DAY_IN_SECONDS)));
                let maxMax = createDuration(Math.max(max.seconds, minMin.seconds + DAY_IN_SECONDS));
                loop: for (let date of $_viewDates) {
                    let start = addDuration(cloneDate(date), min);
                    let end = addDuration(cloneDate(date), max);
                    let minStart = addDuration(cloneDate(date), minMin);
                    let maxEnd = addDuration(cloneDate(date), maxMax);
                    for (let event of $_events) {
                        if (event.display === 'auto' && event.start < maxEnd && event.end > minStart) {
                            if (event.start < start) {
                                let seconds = Math.max((event.start - date) / 1000, minMin.seconds);
                                if (seconds < min.seconds) {
                                    min.seconds = seconds;
                                }
                            }
                            if (event.end > end) {
                                let seconds = Math.min((event.end - date) / 1000, maxMax.seconds);
                                if (seconds > max.seconds) {
                                    max.seconds = seconds;
                                }
                            }
                            if (min.seconds === minMin.seconds && max.seconds === maxMax.seconds) {
                                break loop;
                            }
                        }
                    }
                }
            }

            return {min, max};
        }
    );
}

class State {
    constructor(state) {
        this._slotTimeLimits = slotTimeLimits(state);  // flexible limits
        this._times = times(state, this);
    }
}

/* packages/time-grid/src/Header.svelte generated by Svelte v3.38.2 */

function get_each_context$3(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[8] = list[i];
	return child_ctx;
}

// (11:3) {#each $_times as time}
function create_each_block$3(ctx) {
	let div;
	let t_value = /*time*/ ctx[8] + "";
	let t;
	let div_class_value;

	return {
		c() {
			div = element("div");
			t = text(t_value);
			attr(div, "class", div_class_value = /*$theme*/ ctx[0].time);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, t);
		},
		p(ctx, dirty) {
			if (dirty & /*$_times*/ 4 && t_value !== (t_value = /*time*/ ctx[8] + "")) set_data(t, t_value);

			if (dirty & /*$theme*/ 1 && div_class_value !== (div_class_value = /*$theme*/ ctx[0].time)) {
				attr(div, "class", div_class_value);
			}
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

function create_fragment$4(ctx) {
	let div5;
	let div1;
	let div0;
	let div0_class_value;
	let div1_class_value;
	let t0;
	let div3;
	let div2;
	let div2_class_value;
	let t1;
	let div3_class_value;
	let t2;
	let div4;
	let div4_class_value;
	let div5_class_value;
	let current;
	let each_value = /*$_times*/ ctx[2];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
	}

	const default_slot_template = /*#slots*/ ctx[7].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);

	return {
		c() {
			div5 = element("div");
			div1 = element("div");
			div0 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t0 = space();
			div3 = element("div");
			div2 = element("div");
			t1 = space();
			if (default_slot) default_slot.c();
			t2 = space();
			div4 = element("div");
			attr(div0, "class", div0_class_value = /*$theme*/ ctx[0].hiddenTimes);
			attr(div1, "class", div1_class_value = /*$theme*/ ctx[0].sidebar);
			attr(div2, "class", div2_class_value = /*$theme*/ ctx[0].lines);
			attr(div3, "class", div3_class_value = /*$theme*/ ctx[0].days);
			attr(div4, "class", div4_class_value = /*$theme*/ ctx[0].hiddenScroll);

			attr(div5, "class", div5_class_value = "" + (/*$theme*/ ctx[0].header + (/*$_scrollable*/ ctx[1]
			? " " + /*$theme*/ ctx[0].withScroll
			: "")));
		},
		m(target, anchor) {
			insert(target, div5, anchor);
			append(div5, div1);
			append(div1, div0);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div0, null);
			}

			append(div5, t0);
			append(div5, div3);
			append(div3, div2);
			append(div3, t1);

			if (default_slot) {
				default_slot.m(div3, null);
			}

			append(div5, t2);
			append(div5, div4);
			current = true;
		},
		p(ctx, [dirty]) {
			if (dirty & /*$theme, $_times*/ 5) {
				each_value = /*$_times*/ ctx[2];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$3(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$3(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div0, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (!current || dirty & /*$theme*/ 1 && div0_class_value !== (div0_class_value = /*$theme*/ ctx[0].hiddenTimes)) {
				attr(div0, "class", div0_class_value);
			}

			if (!current || dirty & /*$theme*/ 1 && div1_class_value !== (div1_class_value = /*$theme*/ ctx[0].sidebar)) {
				attr(div1, "class", div1_class_value);
			}

			if (!current || dirty & /*$theme*/ 1 && div2_class_value !== (div2_class_value = /*$theme*/ ctx[0].lines)) {
				attr(div2, "class", div2_class_value);
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 64)) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[6], dirty, null, null);
				}
			}

			if (!current || dirty & /*$theme*/ 1 && div3_class_value !== (div3_class_value = /*$theme*/ ctx[0].days)) {
				attr(div3, "class", div3_class_value);
			}

			if (!current || dirty & /*$theme*/ 1 && div4_class_value !== (div4_class_value = /*$theme*/ ctx[0].hiddenScroll)) {
				attr(div4, "class", div4_class_value);
			}

			if (!current || dirty & /*$theme, $_scrollable*/ 3 && div5_class_value !== (div5_class_value = "" + (/*$theme*/ ctx[0].header + (/*$_scrollable*/ ctx[1]
			? " " + /*$theme*/ ctx[0].withScroll
			: "")))) {
				attr(div5, "class", div5_class_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div5);
			destroy_each(each_blocks, detaching);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$4($$self, $$props, $$invalidate) {
	let $theme;
	let $_scrollable;
	let $_times;
	let { $$slots: slots = {}, $$scope } = $$props;
	let { _scrollable, theme } = getContext("state");
	component_subscribe($$self, _scrollable, value => $$invalidate(1, $_scrollable = value));
	component_subscribe($$self, theme, value => $$invalidate(0, $theme = value));
	let { _times } = getContext("view-state");
	component_subscribe($$self, _times, value => $$invalidate(2, $_times = value));

	$$self.$$set = $$props => {
		if ("$$scope" in $$props) $$invalidate(6, $$scope = $$props.$$scope);
	};

	return [$theme, $_scrollable, $_times, _scrollable, theme, _times, $$scope, slots];
}

class Header extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$4, create_fragment$4, safe_not_equal, {});
	}
}

/* packages/time-grid/src/Body.svelte generated by Svelte v3.38.2 */

function get_each_context$2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[26] = list[i];
	return child_ctx;
}

function get_each_context_1$2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[29] = list[i];
	return child_ctx;
}

// (42:3) {#each $_times as time}
function create_each_block_1$2(ctx) {
	let div;
	let t_value = /*time*/ ctx[29] + "";
	let t;
	let div_class_value;

	return {
		c() {
			div = element("div");
			t = text(t_value);
			attr(div, "class", div_class_value = /*$theme*/ ctx[4].time);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, t);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*$_times*/ 2 && t_value !== (t_value = /*time*/ ctx[29] + "")) set_data(t, t_value);

			if (dirty[0] & /*$theme*/ 16 && div_class_value !== (div_class_value = /*$theme*/ ctx[4].time)) {
				attr(div, "class", div_class_value);
			}
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (48:4) {#each lines as line}
function create_each_block$2(ctx) {
	let div;
	let div_class_value;

	return {
		c() {
			div = element("div");
			attr(div, "class", div_class_value = /*$theme*/ ctx[4].line);
		},
		m(target, anchor) {
			insert(target, div, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*$theme*/ 16 && div_class_value !== (div_class_value = /*$theme*/ ctx[4].line)) {
				attr(div, "class", div_class_value);
			}
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

function create_fragment$3(ctx) {
	let div4;
	let div3;
	let div0;
	let div0_class_value;
	let t0;
	let div2;
	let div1;
	let div1_class_value;
	let t1;
	let div2_class_value;
	let div3_class_value;
	let div4_class_value;
	let current;
	let mounted;
	let dispose;
	let each_value_1 = /*$_times*/ ctx[1];
	let each_blocks_1 = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks_1[i] = create_each_block_1$2(get_each_context_1$2(ctx, each_value_1, i));
	}

	let each_value = /*lines*/ ctx[3];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
	}

	const default_slot_template = /*#slots*/ ctx[21].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[20], null);

	return {
		c() {
			div4 = element("div");
			div3 = element("div");
			div0 = element("div");

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].c();
			}

			t0 = space();
			div2 = element("div");
			div1 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t1 = space();
			if (default_slot) default_slot.c();
			attr(div0, "class", div0_class_value = /*$theme*/ ctx[4].sidebar);
			attr(div1, "class", div1_class_value = /*$theme*/ ctx[4].lines);
			attr(div2, "class", div2_class_value = /*$theme*/ ctx[4].days);
			attr(div3, "class", div3_class_value = /*$theme*/ ctx[4].content);

			attr(div4, "class", div4_class_value = "" + (/*$theme*/ ctx[4].body + " " + /*$theme*/ ctx[4].week + (/*compact*/ ctx[2]
			? " " + /*$theme*/ ctx[4].compact
			: "")));
		},
		m(target, anchor) {
			insert(target, div4, anchor);
			append(div4, div3);
			append(div3, div0);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].m(div0, null);
			}

			append(div3, t0);
			append(div3, div2);
			append(div2, div1);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div1, null);
			}

			append(div2, t1);

			if (default_slot) {
				default_slot.m(div2, null);
			}

			/*div4_binding*/ ctx[22](div4);
			current = true;

			if (!mounted) {
				dispose = [
					listen(window, "resize", /*recheckScrollable*/ ctx[13]),
					listen(div4, "scroll", /*handleScroll*/ ctx[14])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*$theme, $_times*/ 18) {
				each_value_1 = /*$_times*/ ctx[1];
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1$2(ctx, each_value_1, i);

					if (each_blocks_1[i]) {
						each_blocks_1[i].p(child_ctx, dirty);
					} else {
						each_blocks_1[i] = create_each_block_1$2(child_ctx);
						each_blocks_1[i].c();
						each_blocks_1[i].m(div0, null);
					}
				}

				for (; i < each_blocks_1.length; i += 1) {
					each_blocks_1[i].d(1);
				}

				each_blocks_1.length = each_value_1.length;
			}

			if (!current || dirty[0] & /*$theme*/ 16 && div0_class_value !== (div0_class_value = /*$theme*/ ctx[4].sidebar)) {
				attr(div0, "class", div0_class_value);
			}

			if (dirty[0] & /*$theme, lines*/ 24) {
				each_value = /*lines*/ ctx[3];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$2(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$2(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div1, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (!current || dirty[0] & /*$theme*/ 16 && div1_class_value !== (div1_class_value = /*$theme*/ ctx[4].lines)) {
				attr(div1, "class", div1_class_value);
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty[0] & /*$$scope*/ 1048576)) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[20], dirty, null, null);
				}
			}

			if (!current || dirty[0] & /*$theme*/ 16 && div2_class_value !== (div2_class_value = /*$theme*/ ctx[4].days)) {
				attr(div2, "class", div2_class_value);
			}

			if (!current || dirty[0] & /*$theme*/ 16 && div3_class_value !== (div3_class_value = /*$theme*/ ctx[4].content)) {
				attr(div3, "class", div3_class_value);
			}

			if (!current || dirty[0] & /*$theme, compact*/ 20 && div4_class_value !== (div4_class_value = "" + (/*$theme*/ ctx[4].body + " " + /*$theme*/ ctx[4].week + (/*compact*/ ctx[2]
			? " " + /*$theme*/ ctx[4].compact
			: "")))) {
				attr(div4, "class", div4_class_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div4);
			destroy_each(each_blocks_1, detaching);
			destroy_each(each_blocks, detaching);
			if (default_slot) default_slot.d(detaching);
			/*div4_binding*/ ctx[22](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance$3($$self, $$props, $$invalidate) {
	let $slotDuration;
	let $_times;
	let $_slotTimeLimits;
	let $_viewDates;
	let $scrollTime;
	let $_scrollable;
	let $_interaction;
	let $theme;
	let { $$slots: slots = {}, $$scope } = $$props;
	let { slotDuration, _intlSlotLabel, _viewDates, scrollTime, _scrollable, theme, _interaction } = getContext("state");
	component_subscribe($$self, slotDuration, value => $$invalidate(16, $slotDuration = value));
	component_subscribe($$self, _viewDates, value => $$invalidate(18, $_viewDates = value));
	component_subscribe($$self, scrollTime, value => $$invalidate(19, $scrollTime = value));
	component_subscribe($$self, _scrollable, value => $$invalidate(23, $_scrollable = value));
	component_subscribe($$self, theme, value => $$invalidate(4, $theme = value));
	component_subscribe($$self, _interaction, value => $$invalidate(24, $_interaction = value));
	let { _slotTimeLimits, _times } = getContext("view-state");
	component_subscribe($$self, _slotTimeLimits, value => $$invalidate(17, $_slotTimeLimits = value));
	component_subscribe($$self, _times, value => $$invalidate(1, $_times = value));
	let el;
	let compact;
	let lines = [];
	let timeLimitMin;

	function recheckScrollable() {
		set_store_value(_scrollable, $_scrollable = hasYScroll(el), $_scrollable);
	}

	function handleScroll() {
		if ($_interaction.drag) {
			$_interaction.drag.handleScroll();
		}
	}

	function div4_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			el = $$value;
			(((((($$invalidate(0, el), $$invalidate(18, $_viewDates)), $$invalidate(19, $scrollTime)), $$invalidate(15, timeLimitMin)), $$invalidate(16, $slotDuration)), $$invalidate(1, $_times)), $$invalidate(17, $_slotTimeLimits));
		});
	}

	$$self.$$set = $$props => {
		if ("$$scope" in $$props) $$invalidate(20, $$scope = $$props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*$slotDuration, $_times, $_slotTimeLimits*/ 196610) {
			{
				$$invalidate(2, compact = $slotDuration.seconds >= 3600);
				$$invalidate(3, lines.length = $_times.length, lines);

				// Use intermediate variable so that changes in _slotTimeLimits do not trigger setting the el.scrollTop
				$$invalidate(15, timeLimitMin = $_slotTimeLimits.min.seconds);
			}
		}

		if ($$self.$$.dirty[0] & /*el, $_viewDates, $scrollTime, timeLimitMin, $slotDuration*/ 884737) {
			if (el && $_viewDates) {
				$$invalidate(0, el.scrollTop = ($scrollTime.seconds - timeLimitMin) / $slotDuration.seconds * 24 - 12, el);
			}
		}

		if ($$self.$$.dirty[0] & /*el, $_times, $slotDuration*/ 65539) {
			if (el && $_times && $slotDuration) {
				tick().then(recheckScrollable);
			}
		}
	};

	return [
		el,
		$_times,
		compact,
		lines,
		$theme,
		slotDuration,
		_viewDates,
		scrollTime,
		_scrollable,
		theme,
		_interaction,
		_slotTimeLimits,
		_times,
		recheckScrollable,
		handleScroll,
		timeLimitMin,
		$slotDuration,
		$_slotTimeLimits,
		$_viewDates,
		$scrollTime,
		$$scope,
		slots,
		div4_binding
	];
}

class Body extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$3, create_fragment$3, safe_not_equal, {}, [-1, -1]);
	}
}

function groupEventChunks(chunks) {
    if (!chunks.length) {
        return;
    }

    sortEventChunks(chunks);

    // Group
    let group = {
        columns: [],
        end: chunks[0].end
    };
    for (let chunk of chunks) {
        let c = 0;
        if (chunk.start < group.end) {
            for (; c < group.columns.length; ++c) {
                if (group.columns[c][group.columns[c].length - 1].end <= chunk.start) {
                    break;
                }
            }
            if (chunk.end > group.end) {
                group.end = chunk.end;
            }
        } else {
            group = {
                columns: [],
                end: chunk.end
            };
        }

        if (group.columns.length < c + 1) {
            group.columns.push([]);
        }
        group.columns[c].push(chunk);

        chunk.group = group;
        chunk.column = c;
    }
}

/* packages/time-grid/src/Event.svelte generated by Svelte v3.38.2 */

function create_fragment$2(ctx) {
	let div;
	let setContent_action;
	let mounted;
	let dispose;

	return {
		c() {
			div = element("div");
			attr(div, "class", /*classes*/ ctx[3]);
			attr(div, "style", /*style*/ ctx[4]);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			/*div_binding*/ ctx[36](div);

			if (!mounted) {
				dispose = [
					action_destroyer(setContent_action = setContent.call(null, div, /*content*/ ctx[5])),
					listen(div, "click", function () {
						if (is_function(/*createHandler*/ ctx[23](/*$eventClick*/ ctx[6], /*display*/ ctx[0]))) /*createHandler*/ ctx[23](/*$eventClick*/ ctx[6], /*display*/ ctx[0]).apply(this, arguments);
					}),
					listen(div, "mouseenter", function () {
						if (is_function(/*createHandler*/ ctx[23](/*$eventMouseEnter*/ ctx[7], /*display*/ ctx[0]))) /*createHandler*/ ctx[23](/*$eventMouseEnter*/ ctx[7], /*display*/ ctx[0]).apply(this, arguments);
					}),
					listen(div, "mouseleave", function () {
						if (is_function(/*createHandler*/ ctx[23](/*$eventMouseLeave*/ ctx[8], /*display*/ ctx[0]))) /*createHandler*/ ctx[23](/*$eventMouseLeave*/ ctx[8], /*display*/ ctx[0]).apply(this, arguments);
					}),
					listen(div, "mousedown", function () {
						if (is_function(/*createDragStartHandler*/ ctx[24](/*$_interaction*/ ctx[1], /*display*/ ctx[0]))) /*createDragStartHandler*/ ctx[24](/*$_interaction*/ ctx[1], /*display*/ ctx[0]).apply(this, arguments);
					}),
					listen(div, "touchstart", function () {
						if (is_function(/*createDragStartHandler*/ ctx[24](/*$_interaction*/ ctx[1], /*display*/ ctx[0]))) /*createDragStartHandler*/ ctx[24](/*$_interaction*/ ctx[1], /*display*/ ctx[0]).apply(this, arguments);
					})
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty[0] & /*classes*/ 8) {
				attr(div, "class", /*classes*/ ctx[3]);
			}

			if (dirty[0] & /*style*/ 16) {
				attr(div, "style", /*style*/ ctx[4]);
			}

			if (setContent_action && is_function(setContent_action.update) && dirty[0] & /*content*/ 32) setContent_action.update.call(null, /*content*/ ctx[5]);
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div);
			/*div_binding*/ ctx[36](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance$2($$self, $$props, $$invalidate) {
	let $slotDuration;
	let $_slotTimeLimits;
	let $eventBackgroundColor;
	let $eventColor;
	let $theme;
	let $_interaction;
	let $displayEventEnd;
	let $eventContent;
	let $_intlEventTime;
	let $_view;
	let $eventDidMount;
	let $eventClick;
	let $eventMouseEnter;
	let $eventMouseLeave;
	let { date } = $$props;
	let { chunk } = $$props;
	let { displayEventEnd, eventBackgroundColor, eventColor, eventContent, eventClick, eventDidMount, eventMouseEnter, eventMouseLeave, slotDuration, theme, _view, _intlEventTime, _interaction } = getContext("state");
	component_subscribe($$self, displayEventEnd, value => $$invalidate(32, $displayEventEnd = value));
	component_subscribe($$self, eventBackgroundColor, value => $$invalidate(29, $eventBackgroundColor = value));
	component_subscribe($$self, eventColor, value => $$invalidate(30, $eventColor = value));
	component_subscribe($$self, eventContent, value => $$invalidate(33, $eventContent = value));
	component_subscribe($$self, eventClick, value => $$invalidate(6, $eventClick = value));
	component_subscribe($$self, eventDidMount, value => $$invalidate(38, $eventDidMount = value));
	component_subscribe($$self, eventMouseEnter, value => $$invalidate(7, $eventMouseEnter = value));
	component_subscribe($$self, eventMouseLeave, value => $$invalidate(8, $eventMouseLeave = value));
	component_subscribe($$self, slotDuration, value => $$invalidate(27, $slotDuration = value));
	component_subscribe($$self, theme, value => $$invalidate(31, $theme = value));
	component_subscribe($$self, _view, value => $$invalidate(35, $_view = value));
	component_subscribe($$self, _intlEventTime, value => $$invalidate(34, $_intlEventTime = value));
	component_subscribe($$self, _interaction, value => $$invalidate(1, $_interaction = value));
	let { _slotTimeLimits, _viewResources } = getContext("view-state");
	component_subscribe($$self, _slotTimeLimits, value => $$invalidate(28, $_slotTimeLimits = value));
	let el;
	let display;
	let classes;
	let style;
	let content;
	let timeText;

	onMount(() => {
		if (is_function($eventDidMount)) {
			$eventDidMount({
				event: toEventWithLocalDates(chunk.event),
				timeText,
				el,
				view: toViewWithLocalDates($_view)
			});
		}
	});

	function createHandler(fn, display) {
		return display !== "preview" && is_function(fn)
		? jsEvent => fn({
				event: toEventWithLocalDates(chunk.event),
				el,
				jsEvent,
				view: toViewWithLocalDates($_view)
			})
		: undefined;
	}

	function createDragStartHandler(interaction, display) {
		return display === "auto" && interaction.drag
		? jsEvent => interaction.drag.startTimeGrid(chunk.event, el, jsEvent, _viewResources)
		: undefined;
	}

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			el = $$value;
			$$invalidate(2, el);
		});
	}

	$$self.$$set = $$props => {
		if ("date" in $$props) $$invalidate(25, date = $$props.date);
		if ("chunk" in $$props) $$invalidate(26, chunk = $$props.chunk);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*chunk, $slotDuration, $_slotTimeLimits, date, $eventBackgroundColor, $eventColor, style, display, $_interaction*/ 2113929235 | $$self.$$.dirty[1] & /*$theme*/ 1) {
			{
				$$invalidate(0, display = chunk.event.display);

				// Style
				let step = $slotDuration.seconds / 60;

				let offset = $_slotTimeLimits.min.seconds / 60;
				let start = (chunk.start - date) / 1000 / 60;
				let end = (chunk.end - date) / 1000 / 60;
				let top = (start - offset) / step * 24;
				let height = (end - start) / step * 24;
				let maxHeight = ($_slotTimeLimits.max.seconds / 60 - start) / step * 24;
				let bgColor = chunk.event.backgroundColor || $eventBackgroundColor || $eventColor;
				$$invalidate(4, style = `top:${top}px;` + `min-height:${height}px;` + `height:${height}px;` + `max-height:${maxHeight}px;`);

				if (bgColor) {
					$$invalidate(4, style += `background-color:${bgColor};`);
				}

				if (display === "auto" || display === "ghost") {
					$$invalidate(4, style += `z-index:${chunk.column + 1};` + `left:${100 / chunk.group.columns.length * chunk.column}%;` + `width:${100 / chunk.group.columns.length * 0.5 * (1 + chunk.group.columns.length - chunk.column)}%;`);
				}

				// Class
				let className = display === "background" ? $theme.bgEvent : $theme.event;

				$$invalidate(3, classes = $_interaction.drag
				? $_interaction.drag.classes(display, className)
				: className);
			}
		}

		if ($$self.$$.dirty[0] & /*chunk*/ 67108864 | $$self.$$.dirty[1] & /*$displayEventEnd, $eventContent, $theme, $_intlEventTime, $_view*/ 31) {
			// Content
			$$invalidate(5, [timeText, content] = createEventContent(chunk, $displayEventEnd, $eventContent, $theme, $_intlEventTime, $_view), content);
		}
	};

	return [
		display,
		$_interaction,
		el,
		classes,
		style,
		content,
		$eventClick,
		$eventMouseEnter,
		$eventMouseLeave,
		displayEventEnd,
		eventBackgroundColor,
		eventColor,
		eventContent,
		eventClick,
		eventDidMount,
		eventMouseEnter,
		eventMouseLeave,
		slotDuration,
		theme,
		_view,
		_intlEventTime,
		_interaction,
		_slotTimeLimits,
		createHandler,
		createDragStartHandler,
		date,
		chunk,
		$slotDuration,
		$_slotTimeLimits,
		$eventBackgroundColor,
		$eventColor,
		$theme,
		$displayEventEnd,
		$eventContent,
		$_intlEventTime,
		$_view,
		div_binding
	];
}

class Event extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$2, create_fragment$2, safe_not_equal, { date: 25, chunk: 26 }, [-1, -1]);
	}
}

/* packages/time-grid/src/Day.svelte generated by Svelte v3.38.2 */

function get_each_context$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[28] = list[i];
	return child_ctx;
}

function get_each_context_1$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[28] = list[i];
	return child_ctx;
}

// (82:2) {#each bgChunks as chunk}
function create_each_block_1$1(ctx) {
	let event;
	let current;

	event = new Event({
			props: {
				date: /*date*/ ctx[0],
				chunk: /*chunk*/ ctx[28]
			}
		});

	return {
		c() {
			create_component(event.$$.fragment);
		},
		m(target, anchor) {
			mount_component(event, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const event_changes = {};
			if (dirty[0] & /*date*/ 1) event_changes.date = /*date*/ ctx[0];
			if (dirty[0] & /*bgChunks*/ 4) event_changes.chunk = /*chunk*/ ctx[28];
			event.$set(event_changes);
		},
		i(local) {
			if (current) return;
			transition_in(event.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(event.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(event, detaching);
		}
	};
}

// (87:2) {#each chunks as chunk}
function create_each_block$1(ctx) {
	let event;
	let current;

	event = new Event({
			props: {
				date: /*date*/ ctx[0],
				chunk: /*chunk*/ ctx[28]
			}
		});

	return {
		c() {
			create_component(event.$$.fragment);
		},
		m(target, anchor) {
			mount_component(event, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const event_changes = {};
			if (dirty[0] & /*date*/ 1) event_changes.date = /*date*/ ctx[0];
			if (dirty[0] & /*chunks*/ 2) event_changes.chunk = /*chunk*/ ctx[28];
			event.$set(event_changes);
		},
		i(local) {
			if (current) return;
			transition_in(event.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(event.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(event, detaching);
		}
	};
}

// (90:2) {#if dragChunk}
function create_if_block(ctx) {
	let event;
	let current;

	event = new Event({
			props: {
				date: /*date*/ ctx[0],
				chunk: /*dragChunk*/ ctx[3]
			}
		});

	return {
		c() {
			create_component(event.$$.fragment);
		},
		m(target, anchor) {
			mount_component(event, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const event_changes = {};
			if (dirty[0] & /*date*/ 1) event_changes.date = /*date*/ ctx[0];
			if (dirty[0] & /*dragChunk*/ 8) event_changes.chunk = /*dragChunk*/ ctx[3];
			event.$set(event_changes);
		},
		i(local) {
			if (current) return;
			transition_in(event.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(event.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(event, detaching);
		}
	};
}

function create_fragment$1(ctx) {
	let div2;
	let div0;
	let div0_class_value;
	let t0;
	let div1;
	let t1;
	let div1_class_value;
	let div2_class_value;
	let current;
	let mounted;
	let dispose;
	let each_value_1 = /*bgChunks*/ ctx[2];
	let each_blocks_1 = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks_1[i] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i));
	}

	const out = i => transition_out(each_blocks_1[i], 1, 1, () => {
		each_blocks_1[i] = null;
	});

	let each_value = /*chunks*/ ctx[1];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
	}

	const out_1 = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	let if_block = /*dragChunk*/ ctx[3] && create_if_block(ctx);

	return {
		c() {
			div2 = element("div");
			div0 = element("div");

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].c();
			}

			t0 = space();
			div1 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t1 = space();
			if (if_block) if_block.c();
			attr(div0, "class", div0_class_value = /*$theme*/ ctx[6].bgEvents);
			attr(div1, "class", div1_class_value = /*$theme*/ ctx[6].events);

			attr(div2, "class", div2_class_value = "" + (/*$theme*/ ctx[6].day + (/*isToday*/ ctx[4] ? " " + /*$theme*/ ctx[6].today : "") + (/*highlight*/ ctx[5]
			? " " + /*$theme*/ ctx[6].highlight
			: "")));
		},
		m(target, anchor) {
			insert(target, div2, anchor);
			append(div2, div0);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].m(div0, null);
			}

			append(div2, t0);
			append(div2, div1);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div1, null);
			}

			append(div1, t1);
			if (if_block) if_block.m(div1, null);
			current = true;

			if (!mounted) {
				dispose = listen(div2, "click", function () {
					if (is_function(/*createClickHandler*/ ctx[16](/*$dateClick*/ ctx[7]))) /*createClickHandler*/ ctx[16](/*$dateClick*/ ctx[7]).apply(this, arguments);
				});

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty[0] & /*date, bgChunks*/ 5) {
				each_value_1 = /*bgChunks*/ ctx[2];
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1$1(ctx, each_value_1, i);

					if (each_blocks_1[i]) {
						each_blocks_1[i].p(child_ctx, dirty);
						transition_in(each_blocks_1[i], 1);
					} else {
						each_blocks_1[i] = create_each_block_1$1(child_ctx);
						each_blocks_1[i].c();
						transition_in(each_blocks_1[i], 1);
						each_blocks_1[i].m(div0, null);
					}
				}

				group_outros();

				for (i = each_value_1.length; i < each_blocks_1.length; i += 1) {
					out(i);
				}

				check_outros();
			}

			if (!current || dirty[0] & /*$theme*/ 64 && div0_class_value !== (div0_class_value = /*$theme*/ ctx[6].bgEvents)) {
				attr(div0, "class", div0_class_value);
			}

			if (dirty[0] & /*date, chunks*/ 3) {
				each_value = /*chunks*/ ctx[1];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$1(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$1(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(div1, t1);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out_1(i);
				}

				check_outros();
			}

			if (/*dragChunk*/ ctx[3]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*dragChunk*/ 8) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div1, null);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (!current || dirty[0] & /*$theme*/ 64 && div1_class_value !== (div1_class_value = /*$theme*/ ctx[6].events)) {
				attr(div1, "class", div1_class_value);
			}

			if (!current || dirty[0] & /*$theme, isToday, highlight*/ 112 && div2_class_value !== (div2_class_value = "" + (/*$theme*/ ctx[6].day + (/*isToday*/ ctx[4] ? " " + /*$theme*/ ctx[6].today : "") + (/*highlight*/ ctx[5]
			? " " + /*$theme*/ ctx[6].highlight
			: "")))) {
				attr(div2, "class", div2_class_value);
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value_1.length; i += 1) {
				transition_in(each_blocks_1[i]);
			}

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			transition_in(if_block);
			current = true;
		},
		o(local) {
			each_blocks_1 = each_blocks_1.filter(Boolean);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				transition_out(each_blocks_1[i]);
			}

			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div2);
			destroy_each(each_blocks_1, detaching);
			destroy_each(each_blocks, detaching);
			if (if_block) if_block.d();
			mounted = false;
			dispose();
		}
	};
}

function instance$1($$self, $$props, $$invalidate) {
	let $_slotTimeLimits;
	let $_events;
	let $_dragEvent;
	let $highlightedDates;
	let $slotDuration;
	let $_view;
	let $theme;
	let $dateClick;
	let { date } = $$props;
	let { resource = undefined } = $$props;
	let { _events, _dragEvent, dateClick, highlightedDates, slotDuration, _view, theme } = getContext("state");
	component_subscribe($$self, _events, value => $$invalidate(21, $_events = value));
	component_subscribe($$self, _dragEvent, value => $$invalidate(22, $_dragEvent = value));
	component_subscribe($$self, dateClick, value => $$invalidate(7, $dateClick = value));
	component_subscribe($$self, highlightedDates, value => $$invalidate(23, $highlightedDates = value));
	component_subscribe($$self, slotDuration, value => $$invalidate(24, $slotDuration = value));
	component_subscribe($$self, _view, value => $$invalidate(25, $_view = value));
	component_subscribe($$self, theme, value => $$invalidate(6, $theme = value));
	let { _slotTimeLimits } = getContext("view-state");
	component_subscribe($$self, _slotTimeLimits, value => $$invalidate(20, $_slotTimeLimits = value));
	let chunks, bgChunks, dragChunk;
	let today = setMidnight(createDate()), isToday, highlight;
	let start, end;

	function createClickHandler(fn) {
		return is_function(fn)
		? jsEvent => {
				let r = rect(jsEvent.currentTarget);
				let y = jsEvent.clientY - r.top;
				let d = addDuration(cloneDate(date), $slotDuration, Math.floor(y / 24 + $_slotTimeLimits.min.seconds / $slotDuration.seconds));

				fn({
					date: toLocalDate(d),
					jsEvent,
					view: toViewWithLocalDates($_view),
					resource
				});
			}
		: undefined;
	}

	function intersects(event) {
		return event.start < end && event.end > start && (resource === undefined || event.resourceIds.includes(resource.id));
	}

	$$self.$$set = $$props => {
		if ("date" in $$props) $$invalidate(0, date = $$props.date);
		if ("resource" in $$props) $$invalidate(17, resource = $$props.resource);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*date, $_slotTimeLimits*/ 1048577) {
			{
				$$invalidate(18, start = addDuration(cloneDate(date), $_slotTimeLimits.min));
				$$invalidate(19, end = addDuration(cloneDate(date), $_slotTimeLimits.max));
			}
		}

		if ($$self.$$.dirty[0] & /*$_events, start, end, bgChunks, chunks*/ 2883590) {
			{
				$$invalidate(1, chunks = []);
				$$invalidate(2, bgChunks = []);

				for (let event of $_events) {
					if (intersects(event)) {
						let chunk = createEventChunk(event, start, end);

						switch (event.display) {
							case "background":
								bgChunks.push(chunk);
								break;
							default:
								chunks.push(chunk);
						}
					}
				}

				groupEventChunks(chunks);
			}
		}

		if ($$self.$$.dirty[0] & /*$_dragEvent, start, end*/ 4980736) {
			// Drag & drop
			if ($_dragEvent && intersects($_dragEvent)) {
				$$invalidate(3, dragChunk = createEventChunk($_dragEvent, start, end));
			} else {
				$$invalidate(3, dragChunk = null);
			}
		}

		if ($$self.$$.dirty[0] & /*date, $highlightedDates*/ 8388609) {
			{
				$$invalidate(4, isToday = datesEqual(date, today));
				$$invalidate(5, highlight = $highlightedDates.some(d => datesEqual(d, date)));
			}
		}
	};

	return [
		date,
		chunks,
		bgChunks,
		dragChunk,
		isToday,
		highlight,
		$theme,
		$dateClick,
		_events,
		_dragEvent,
		dateClick,
		highlightedDates,
		slotDuration,
		_view,
		theme,
		_slotTimeLimits,
		createClickHandler,
		resource,
		start,
		end,
		$_slotTimeLimits,
		$_events,
		$_dragEvent,
		$highlightedDates
	];
}

class Day extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$1, create_fragment$1, safe_not_equal, { date: 0, resource: 17 }, [-1, -1]);
	}
}

/* packages/time-grid/src/View.svelte generated by Svelte v3.38.2 */

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[7] = list[i];
	return child_ctx;
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[7] = list[i];
	return child_ctx;
}

// (15:1) {#each $_viewDates as date}
function create_each_block_1(ctx) {
	let div;
	let t_value = /*$_intlDayHeader*/ ctx[2].format(/*date*/ ctx[7]) + "";
	let t;
	let div_class_value;

	return {
		c() {
			div = element("div");
			t = text(t_value);
			attr(div, "class", div_class_value = /*$theme*/ ctx[1].day);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, t);
		},
		p(ctx, dirty) {
			if (dirty & /*$_intlDayHeader, $_viewDates*/ 5 && t_value !== (t_value = /*$_intlDayHeader*/ ctx[2].format(/*date*/ ctx[7]) + "")) set_data(t, t_value);

			if (dirty & /*$theme*/ 2 && div_class_value !== (div_class_value = /*$theme*/ ctx[1].day)) {
				attr(div, "class", div_class_value);
			}
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (14:0) <Header>
function create_default_slot_1(ctx) {
	let each_1_anchor;
	let each_value_1 = /*$_viewDates*/ ctx[0];
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert(target, each_1_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*$theme, $_intlDayHeader, $_viewDates*/ 7) {
				each_value_1 = /*$_viewDates*/ ctx[0];
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_1.length;
			}
		},
		d(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach(each_1_anchor);
		}
	};
}

// (20:1) {#each $_viewDates as date}
function create_each_block(ctx) {
	let day;
	let current;
	day = new Day({ props: { date: /*date*/ ctx[7] } });

	return {
		c() {
			create_component(day.$$.fragment);
		},
		m(target, anchor) {
			mount_component(day, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const day_changes = {};
			if (dirty & /*$_viewDates*/ 1) day_changes.date = /*date*/ ctx[7];
			day.$set(day_changes);
		},
		i(local) {
			if (current) return;
			transition_in(day.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(day.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(day, detaching);
		}
	};
}

// (19:0) <Body>
function create_default_slot(ctx) {
	let each_1_anchor;
	let current;
	let each_value = /*$_viewDates*/ ctx[0];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert(target, each_1_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (dirty & /*$_viewDates*/ 1) {
				each_value = /*$_viewDates*/ ctx[0];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach(each_1_anchor);
		}
	};
}

function create_fragment(ctx) {
	let header;
	let t;
	let body;
	let current;

	header = new Header({
			props: {
				$$slots: { default: [create_default_slot_1] },
				$$scope: { ctx }
			}
		});

	body = new Body({
			props: {
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(header.$$.fragment);
			t = space();
			create_component(body.$$.fragment);
		},
		m(target, anchor) {
			mount_component(header, target, anchor);
			insert(target, t, anchor);
			mount_component(body, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const header_changes = {};

			if (dirty & /*$$scope, $_viewDates, $theme, $_intlDayHeader*/ 4103) {
				header_changes.$$scope = { dirty, ctx };
			}

			header.$set(header_changes);
			const body_changes = {};

			if (dirty & /*$$scope, $_viewDates*/ 4097) {
				body_changes.$$scope = { dirty, ctx };
			}

			body.$set(body_changes);
		},
		i(local) {
			if (current) return;
			transition_in(header.$$.fragment, local);
			transition_in(body.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(header.$$.fragment, local);
			transition_out(body.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(header, detaching);
			if (detaching) detach(t);
			destroy_component(body, detaching);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let $_viewDates;
	let $theme;
	let $_intlDayHeader;
	let state = getContext("state");
	let { _viewDates, _intlDayHeader, theme } = state;
	component_subscribe($$self, _viewDates, value => $$invalidate(0, $_viewDates = value));
	component_subscribe($$self, _intlDayHeader, value => $$invalidate(2, $_intlDayHeader = value));
	component_subscribe($$self, theme, value => $$invalidate(1, $theme = value));
	setContext("view-state", new State(state));
	return [$_viewDates, $theme, $_intlDayHeader, _viewDates, _intlDayHeader, theme];
}

class View extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, {});
	}
}

var index = {
	createOptions(options) {
		// Common options
		options.buttonText.timeGridDay = 'day';
		options.buttonText.timeGridWeek = 'week';
		options.view = 'timeGridWeek';
		options.views.timeGridDay = {
			component: View,
			dayHeaderFormat: {weekday: 'long'},
			duration: {days: 1},
			titleFormat: {year: 'numeric', month: 'long', day: 'numeric'}
		};
		options.views.timeGridWeek = {
			component: View,
			duration: {weeks: 1}
		};
	}
};

export default index;
export { Body, Day, Header, State };
